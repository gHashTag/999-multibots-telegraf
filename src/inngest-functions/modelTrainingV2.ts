import { inngest } from '../core/inngest/clients'
import { getBotByName } from '@/core/bot'
import {
  getUserByTelegramId,
  updateUserBalance,
  updateUserLevelPlusOne,
  getUserBalance,
  createModelTrainingV2,
  getUserByTelegramIdString,
} from '@/core/supabase'
import { modeCosts, ModeEnum } from '@/price/helpers/modelsCost'
import { errorMessageAdmin } from '@/helpers'
import axios from 'axios'
import { logger } from '@/utils/logger'

interface TrainingResponse {
  id: string
  status: string
  urls: { get: string }
  error?: string
  finetune_id?: string
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –≤ base64
async function encodeFileToBase64(url: string): Promise<string> {
  const response = await axios.get(url, { responseType: 'arraybuffer' })
  const buffer = Buffer.from(response.data)
  return buffer.toString('base64')
}

// –°–æ–∑–¥–∞–µ–º Inngest —Ñ—É–Ω–∫—Ü–∏—é
export const modelTrainingV2 = inngest.createFunction(
  {
    id: 'model-training-v2',
  },
  { event: 'model/training.v2.requested' },
  async ({ event, step }) => {
    logger.info({
      message: 'üöÄ Model training initiated',
      eventId: event.id,
      data: event.data,
    })

    const {
      zipUrl,
      triggerWord,
      modelName,
      steps,
      telegram_id,
      is_ru,
      bot_name,
    } = event.data

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ
    const userExists = await step.run('check-user-exists', async () => {
      logger.info({
        message: 'üîç Checking user existence',
        telegramId: telegram_id,
        step: 'check-user-exists',
      })

      const user = await getUserByTelegramIdString(telegram_id)
      if (!user) {
        logger.error({
          message: '‚ùå User not found',
          telegramId: telegram_id,
          step: 'check-user-exists',
        })
        throw new Error(`User with ID ${telegram_id} does not exist.`)
      }

      logger.info({
        message: '‚úÖ User found',
        telegramId: telegram_id,
        userId: user.id,
        step: 'check-user-exists',
      })

      return user
    })

    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω –Ω–∞ —É—Ä–æ–≤–Ω–µ 0
    if (userExists.level === 0) {
      await step.run('update-user-level', async () => {
        logger.info({
          message: '‚¨ÜÔ∏è Upgrading user level from 0 to 1',
          telegramId: telegram_id,
          currentLevel: userExists.level,
          step: 'update-user-level',
        })

        await updateUserLevelPlusOne(telegram_id, userExists.level)

        logger.info({
          message: '‚úÖ User level updated successfully',
          telegramId: telegram_id,
          newLevel: 1,
          step: 'update-user-level',
        })
      })
    }

    // –ü–æ–ª—É—á–∞–µ–º –±–æ—Ç –ø–æ –∏–º–µ–Ω–∏
    const botData = (await step.run('get-bot', async () => {
      logger.info({
        message: 'ü§ñ Getting bot instance',
        botName: bot_name,
        step: 'get-bot',
      })

      return getBotByName(bot_name)
    })) as { bot: any }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –±–æ—Ç–∞ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏ getBotByName
    const bot = botData.bot

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –∏ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å
    const balanceInfo = await step.run(
      'check-balance',
      async () => {
        logger.info({
          message: 'üí∞ Checking user balance',
          telegramId: telegram_id,
          step: 'check-balance',
        })

        const currentBalance = await getUserBalance(telegram_id)

        logger.info({
          message: 'üí≤ Current user balance',
          telegramId: telegram_id,
          balance: currentBalance,
          step: 'check-balance',
        })

        const trainingCost = (
          modeCosts[ModeEnum.DigitalAvatarBodyV2] as (steps: number) => number
        )(steps)

        logger.info({
          message: 'üßÆ Calculated training cost',
          telegramId: telegram_id,
          trainingCost: trainingCost,
          trainingSteps: steps,
          step: 'check-balance',
        })

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç—å —Å—Ä–µ–¥—Å—Ç–≤
        if (currentBalance < trainingCost) {
          logger.info('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏', {
            userId: telegram_id,
            balance: currentBalance,
            trainingCost,
          })

          // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–µ —Å—Ä–µ–¥—Å—Ç–≤
          const message = is_ru
            ? `–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ: ${trainingCost} ‚≠êÔ∏è, –Ω–∞ –±–∞–ª–∞–Ω—Å–µ: ${currentBalance} ‚≠êÔ∏è.`
            : `Insufficient funds to train the model. Required: ${trainingCost} ‚≠êÔ∏è, balance: ${currentBalance} ‚≠êÔ∏è.`

          await bot.telegram.sendMessage(telegram_id, message, {
            parse_mode: 'Markdown',
          })

          throw new Error('Insufficient funds for model training')
        }

        // –í–º–µ—Å—Ç–æ processBalanceOperation –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ payment/process
        await inngest.send({
          name: 'payment/process',
          data: {
            telegram_id,
            paymentAmount: trainingCost,
            is_ru,
            bot_name,
            bot,
            description: `Payment for training model: ${modelName}`,
            operation_id: `${telegram_id}-${Date.now()}-training-${modelName.substring(0, 10)}`
          }
        });

        // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –ø–æ—Å–ª–µ —Å–ø–∏—Å–∞–Ω–∏—è
        const updatedUser = await getUserByTelegramIdString(telegram_id)
        
        logger.info({
          message: '‚úÖ Balance check successful',
          telegramId: telegram_id,
          initialBalance: currentBalance,
          newBalance: updatedUser.balance,
          trainingCost: trainingCost,
          step: 'check-balance',
        })
        
        return {
          success: true,
          newBalance: updatedUser.balance,
          prevBalance: currentBalance,
          trainingCost
        }
      }
    )

    try {
      // –ö–æ–¥–∏—Ä—É–µ–º ZIP —Ñ–∞–π–ª –≤ base64
      const encodedZip = await step.run('encode-zip', async () => {
        logger.info({
          message: 'üì¶ Encoding ZIP file to base64',
          zipUrl: zipUrl,
          step: 'encode-zip',
        })

        const result = await encodeFileToBase64(zipUrl)

        logger.info({
          message: '‚úÖ ZIP file encoded successfully',
          zipUrl: zipUrl,
          step: 'encode-zip',
        })

        return result
      })

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ API –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏
      const training = await step.run('create-training', async () => {
        logger.info({
          message: 'üîç Checking environment variables',
          step: 'create-training',
        })

        if (!process.env.BFL_API_KEY) {
          logger.error({
            message: 'üö´ Missing required environment variable',
            variable: 'BFL_API_KEY',
            step: 'create-training',
          })

          throw new Error('BFL_API_KEY is not set')
        }
        if (!process.env.BFL_WEBHOOK_URL) {
          logger.error({
            message: 'üö´ Missing required environment variable',
            variable: 'BFL_WEBHOOK_URL',
            step: 'create-training',
          })

          throw new Error('BFL_WEBHOOK_URL is not set')
        }
        if (!process.env.REPLICATE_USERNAME) {
          logger.error({
            message: 'üö´ Missing required environment variable',
            variable: 'REPLICATE_USERNAME',
            step: 'create-training',
          })

          throw new Error('REPLICATE_USERNAME is not set')
        }

        logger.info({
          message: 'üåê Sending request to BFL API for model creation',
          telegramId: telegram_id,
          triggerWord: triggerWord,
          modelName: modelName,
          steps: steps,
          step: 'create-training',
        })

        const response = await fetch('https://api.us1.bfl.ai/v1/finetune', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Key': process.env.BFL_API_KEY,
          },
          body: JSON.stringify({
            file_data: encodedZip,
            finetune_comment: telegram_id,
            trigger_word: triggerWord,
            mode: 'character',
            iterations: steps,
            learning_rate: 0.000001,
            captioning: true,
            priority: 'high_res_only',
            finetune_type: 'full',
            lora_rank: 32,
            webhook_url: process.env.BFL_WEBHOOK_URL,
            webhook_secret: process.env.BFL_WEBHOOK_SECRET,
          }),
        })

        logger.info({
          message: 'üì° Received response from BFL API',
          statusCode: response.status,
          step: 'create-training',
        })

        if (!response.ok) {
          logger.error({
            message: '‚ùå Failed to create model training',
            statusCode: response.status,
            step: 'create-training',
          })

          throw new Error(
            `Failed to initiate training with new API. Status: ${response.status}`
          )
        }

        const jsonResponse = (await response.json()) as TrainingResponse

        logger.info({
          message: 'üéâ Model training initiated successfully',
          finetune_id: jsonResponse.finetune_id,
          telegramId: telegram_id,
          modelName: modelName,
          step: 'create-training',
        })

        return jsonResponse
      })

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
      await step.run('save-training-to-db', async () => {
        logger.info({
          message: 'üíæ Saving training information to database',
          finetune_id: training.finetune_id,
          telegramId: telegram_id,
          modelName: modelName,
          step: 'save-training-to-db',
        })

        await createModelTrainingV2({
          finetune_id: training.finetune_id,
          telegram_id: telegram_id,
          model_name: modelName,
          trigger_word: triggerWord,
          zip_url: zipUrl,
          steps,
          api: 'bfl',
        })

        logger.info({
          message: '‚úÖ Training information saved successfully',
          finetune_id: training.finetune_id,
          telegramId: telegram_id,
          modelName: modelName,
          step: 'save-training-to-db',
        })
      })

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      await step.run('notify-user', async () => {
        logger.info({
          message: 'üì© Sending notification to user',
          telegramId: telegram_id,
          modelName: modelName,
          step: 'notify-user',
        })

        await bot.telegram.sendMessage(
          telegram_id,
          is_ru
            ? `‚úÖ –û–±—É—á–µ–Ω–∏–µ –≤–∞—à–µ–π –º–æ–¥–µ–ª–∏ "${modelName}" –Ω–∞—á–∞–ª–æ—Å—å! –ú—ã —É–≤–µ–¥–æ–º–∏–º –≤–∞—Å, –∫–æ–≥–¥–∞ –º–æ–¥–µ–ª—å –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–∞.`
            : `‚úÖ Your model "${modelName}" training has started! We'll notify you when it's ready.`
        )

        logger.info({
          message: 'üì® Notification sent successfully',
          telegramId: telegram_id,
          step: 'notify-user',
        })
      })

      logger.info({
        message: 'üèÅ Model training process completed successfully',
        telegramId: telegram_id,
        modelName: modelName,
        finetune_id: training.finetune_id,
      })

      return {
        success: true,
        message: `Training initiated successfully: ${JSON.stringify(training)}`,
      }
    } catch (error) {
      // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ø–∏—Å–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞
      await step.run('refund-balance', async () => {
        logger.info({
          message: '‚ôªÔ∏è Refunding payment due to error',
          telegramId: telegram_id,
          amount: balanceInfo.trainingCost,
          prevBalance: balanceInfo.prevBalance,
          newBalance: balanceInfo.prevBalance,
          step: 'refund-balance',
        })

        await updateUserBalance(
          telegram_id,
          balanceInfo.prevBalance,
          balanceInfo.trainingCost,
          'income',
          `Refund for model training ${modelName} (steps: ${steps})`
        )

        logger.info({
          message: '‚úÖ Payment refunded successfully',
          telegramId: telegram_id,
          newBalance: balanceInfo.prevBalance,
          step: 'refund-balance',
        })
      })

      // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      await step.run('handle-error', async () => {
        logger.error({
          message: 'üö® Error during model training',
          error: error.message,
          stack: error.stack,
          telegramId: telegram_id,
          modelName: modelName,
          triggerWord: triggerWord,
          step: 'handle-error',
        })

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        logger.info({
          message: 'üì± Sending error notification to user',
          telegramId: telegram_id,
          step: 'handle-error',
        })

        await bot.telegram.sendMessage(
          telegram_id,
          is_ru
            ? `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.\n\n–û—à–∏–±–∫–∞: ${error.message}`
            : `‚ùå An error occurred during model generation. Please try again.\n\nError: ${error.message}`
        )

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É
        logger.info({
          message: 'üë®‚Äçüíº Sending error notification to admin',
          telegramId: telegram_id,
          error: error.message,
          step: 'handle-error',
        })

        errorMessageAdmin(error as Error)
      })

      logger.error({
        message: 'üõë Model training process failed',
        telegramId: telegram_id,
        modelName: modelName,
        error: error.message,
      })

      throw error
    }
  }
)
