import { inngest } from '../core/inngest/clients'
import { getBotByName } from '@/core/bot'
import {
  getUserByTelegramId,
  updateUserBalance,
  updateUserLevelPlusOne,
  getUserBalance,
  createModelTrainingV2,
} from '@/core/supabase'
import { modeCosts, ModeEnum } from '@/price/helpers/modelsCost'
import { paymentProcessor } from '@/inngest-functions/paymentProcessor'
import { errorMessageAdmin } from '@/helpers/errorMessageAdmin'
import axios from 'axios'
import { logger } from '@/utils/logger'

// –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å ApiError –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
interface ApiError extends Error {
  response?: {
    status: number
  }
}

interface TrainingResponse {
  id: string
  status: string
  urls: { get: string }
  error?: string
  finetune_id?: string
}

// –ê–∫—Ç–∏–≤–Ω—ã–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
const activeTrainings = new Map<string, { cancel: () => void }>()

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –≤ base64
async function encodeFileToBase64(url: string): Promise<string> {
  const response = await axios.get(url, { responseType: 'arraybuffer' })
  const buffer = Buffer.from(response.data)
  return buffer.toString('base64')
}

// –°–æ–∑–¥–∞–µ–º Inngest —Ñ—É–Ω–∫—Ü–∏—é
export const modelTrainingV2 = inngest.createFunction(
  {
    id: 'model-training-v2',
  },
  { event: 'model-training/v2/requested' },
  async ({ event, step }) => {
    logger.info({
      message: 'üöÄ Model training initiated',
      eventId: event.id,
      data: event.data,
    })

    const {
      zipUrl,
      triggerWord,
      modelName,
      steps,
      telegram_id,
      is_ru,
      bot_name,
    } = event.data

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è
    if (!process.env.BFL_API_KEY) {
      throw new Error('BFL_API_KEY is not set')
    }
    if (!process.env.BFL_WEBHOOK_URL) {
      throw new Error('BFL_WEBHOOK_URL is not set')
    }
    if (!process.env.REPLICATE_USERNAME) {
      throw new Error('REPLICATE_USERNAME is not set')
    }

    // –ü–æ–ª—É—á–∞–µ–º –±–æ—Ç –ø–æ –∏–º–µ–Ω–∏
    const botData = await step.run('get-bot', async () => {
      logger.info({
        message: 'ü§ñ Getting bot instance',
        botName: bot_name,
        step: 'get-bot',
      })

      return getBotByName(bot_name)
    })

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –±–æ—Ç–∞ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏ getBotByName, –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–æ–≤
    const bot = (botData as any).bot

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userExists = await step.run('check-user-exists', async () => {
      logger.info({
        message: 'üîç Checking user existence',
        telegramId: telegram_id,
        step: 'check-user-exists',
      })

      const user = await getUserByTelegramId(telegram_id)
      if (!user) {
        logger.error({
          message: '‚ùå User not found',
          telegramId: telegram_id,
          step: 'check-user-exists',
        })
        throw new Error(`User with ID ${telegram_id} does not exist.`)
      }

      logger.info({
        message: '‚úÖ User found',
        telegramId: telegram_id,
        userId: user.id,
        step: 'check-user-exists',
      })

      return user
    })

    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –æ–Ω –Ω–∞ —É—Ä–æ–≤–Ω–µ 0
    if (userExists.level === 0) {
      await step.run('update-user-level', async () => {
        logger.info({
          message: '‚¨ÜÔ∏è Upgrading user level from 0 to 1',
          telegramId: telegram_id,
          currentLevel: userExists.level,
          step: 'update-user-level',
        })

        await updateUserLevelPlusOne(telegram_id, userExists.level)

        logger.info({
          message: '‚úÖ User level updated successfully',
          telegramId: telegram_id,
          newLevel: 1,
          step: 'update-user-level',
        })
      })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å
    const balanceOperation = await step.run('process-balance', async () => {
      logger.info({
        message: 'üí∞ Processing user balance',
        telegramId: telegram_id,
        step: 'process-balance',
      })

      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –∏ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å
      const currentBalance = await getUserBalance(telegram_id)
      const paymentAmount = (
        modeCosts[ModeEnum.DigitalAvatarBodyV2] as (steps: number) => number
      )(steps)

      logger.info({
        message: 'üí≤ Balance information',
        telegramId: telegram_id,
        currentBalance,
        paymentAmount,
        step: 'process-balance',
      })

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é —Å –±–∞–ª–∞–Ω—Å–æ–º —á–µ—Ä–µ–∑ Inngest —Å–æ–±—ã—Ç–∏—è
      // –¢–∞–∫ –∫–∞–∫ processBalanceOperation –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ paymentProcessor
      await inngest.send({
        name: 'payment/process',
        data: {
          telegram_id,
          paymentAmount,
          is_ru,
          bot,
          bot_name,
          description: `Payment for model training ${modelName} (steps: ${steps})`,
          type: 'outcome',
          metadata: {
            payment_method: 'Training',
            language: is_ru ? 'ru' : 'en',
          },
        },
      })

      logger.info({
        message: '‚úÖ Balance processed successfully',
        telegramId: telegram_id,
        step: 'process-balance',
      })

      return {
        currentBalance,
        paymentAmount,
        balanceCheck: { success: true },
      }
    })

    try {
      // –ö–æ–¥–∏—Ä—É–µ–º ZIP —Ñ–∞–π–ª –≤ base64
      const encodedZip = await step.run('encode-zip', async () => {
        logger.info({
          message: 'üì¶ Encoding ZIP file to base64',
          zipUrl,
          step: 'encode-zip',
        })

        try {
          const result = await encodeFileToBase64(zipUrl)

          logger.info({
            message: '‚úÖ ZIP file encoded successfully',
            zipUrl,
            step: 'encode-zip',
          })

          return result
        } catch (error) {
          logger.error({
            message: '‚ùå Failed to encode ZIP file',
            zipUrl,
            error: error.message,
            step: 'encode-zip',
          })
          throw error
        }
      })

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ API –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–¥–µ–ª–∏
      const training = await step.run('create-training', async () => {
        logger.info({
          message: 'üåê Sending request to BFL API for model creation',
          telegramId: telegram_id,
          triggerWord,
          modelName,
          steps,
          step: 'create-training',
        })

        try {
          const response = await fetch('https://api.us1.bfl.ai/v1/finetune', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Key': process.env.BFL_API_KEY,
            },
            body: JSON.stringify({
              file_data: encodedZip,
              finetune_comment: telegram_id,
              trigger_word: triggerWord,
              mode: 'character',
              iterations: steps,
              learning_rate: 0.000001,
              captioning: true,
              priority: 'high_res_only',
              finetune_type: 'full',
              lora_rank: 32,
              webhook_url: process.env.BFL_WEBHOOK_URL,
              webhook_secret: process.env.BFL_WEBHOOK_SECRET,
            }),
          })

          logger.info({
            message: 'üì° Received response from BFL API',
            statusCode: response.status,
            step: 'create-training',
          })

          if (!response.ok) {
            logger.error({
              message: '‚ùå Failed to create model training',
              statusCode: response.status,
              step: 'create-training',
            })

            throw new Error(
              `Failed to initiate training with new API. Status: ${response.status}`
            )
          }

          const jsonResponse = (await response.json()) as TrainingResponse

          logger.info({
            message: 'üéâ Model training initiated successfully',
            trainingResponse: jsonResponse,
            telegramId: telegram_id,
            modelName,
            step: 'create-training',
          })

          return jsonResponse
        } catch (error) {
          logger.error({
            message: '‚ùå Failed to create training',
            error: error.message,
            step: 'create-training',
          })
          throw error
        }
      })

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
      await step.run('save-training-to-db', async () => {
        logger.info({
          message: 'üíæ Saving training information to database',
          finetune_id: training.finetune_id,
          telegramId: telegram_id,
          modelName,
          step: 'save-training-to-db',
        })

        await createModelTrainingV2({
          finetune_id: training.finetune_id,
          telegram_id,
          model_name: modelName,
          trigger_word: triggerWord,
          zip_url: zipUrl,
          steps,
          api: 'bfl',
        })

        logger.info({
          message: '‚úÖ Training information saved successfully',
          finetune_id: training.finetune_id,
          telegramId: telegram_id,
          modelName,
          step: 'save-training-to-db',
        })
      })

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      await step.run('notify-user', async () => {
        logger.info({
          message: 'üì© Sending notification to user',
          telegramId: telegram_id,
          modelName,
          step: 'notify-user',
        })

        await bot.telegram.sendMessage(
          telegram_id,
          is_ru
            ? `‚úÖ –û–±—É—á–µ–Ω–∏–µ –≤–∞—à–µ–π –º–æ–¥–µ–ª–∏ "${modelName}" –Ω–∞—á–∞–ª–æ—Å—å! –ú—ã —É–≤–µ–¥–æ–º–∏–º –≤–∞—Å, –∫–æ–≥–¥–∞ –º–æ–¥–µ–ª—å –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–∞.`
            : `‚úÖ Your model "${modelName}" training has started! We'll notify you when it's ready.`
        )

        logger.info({
          message: 'üì® Notification sent successfully',
          telegramId: telegram_id,
          step: 'notify-user',
        })
      })

      logger.info({
        message: 'üèÅ Model training process completed successfully',
        telegramId: telegram_id,
        modelName,
        finetune_id: training.finetune_id,
      })

      return {
        success: true,
        message: `Training initiated successfully: ${JSON.stringify(training)}`,
      }
    } catch (error) {
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ä–µ–¥—Å—Ç–≤–∞ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
      await step.run('refund-balance', async () => {
        const currentBalance = balanceOperation.currentBalance as number
        const paymentAmount = balanceOperation.paymentAmount as number

        logger.info({
          message: '‚ôªÔ∏è Refunding payment due to error',
          telegramId: telegram_id,
          amount: paymentAmount,
          currentBalance,
          step: 'refund-balance',
        })

        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Å–∏–≥–Ω–∞—Ç—É—Ä—É —Ñ—É–Ω–∫—Ü–∏–∏ updateUserBalance
        await updateUserBalance({
          telegram_id,
          amount: paymentAmount,
          type: 'income',
          operation_description: `Refund for model training ${modelName} (steps: ${steps})`,
          metadata: {
            payment_method: 'Training',
            bot_name,
            language: is_ru ? 'ru' : 'en',
          },
        })

        logger.info({
          message: '‚úÖ Payment refunded successfully',
          telegramId: telegram_id,
          newBalance: currentBalance + paymentAmount,
          step: 'refund-balance',
        })
      })

      // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      await step.run('handle-error', async () => {
        logger.error({
          message: 'üö® Error during model training',
          error: error.message,
          stack: error.stack,
          telegramId: telegram_id,
          modelName,
          triggerWord,
          step: 'handle-error',
        })

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await bot.telegram.sendMessage(
          telegram_id,
          is_ru
            ? `‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.\n\n–û—à–∏–±–∫–∞: ${error.message}`
            : `‚ùå An error occurred during model generation. Please try again.\n\nError: ${error.message}`
        )

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É
        errorMessageAdmin(error as Error)

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏
        if ((error as ApiError).response?.status === 404) {
          throw new Error(
            `–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–ª–∏ –¥–æ—Å—Ç—É–ø–µ –∫ –º–æ–¥–µ–ª–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ REPLICATE_USERNAME (${process.env.REPLICATE_USERNAME}) –∏ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞.`
          )
        }
      })

      // –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Ü–µ—Å—Å –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö
      activeTrainings.delete(telegram_id)

      logger.error({
        message: 'üõë Model training process failed',
        telegramId: telegram_id,
        modelName,
        error: error.message,
      })

      throw error
    }
  }
)
