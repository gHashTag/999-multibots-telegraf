import { Telegraf } from 'telegraf'
import { MyContext } from '@/interfaces'
import { logger } from '@/utils/logger'

const production = async (
  bot: Telegraf<MyContext>,
  port: number,
  webhookUrl: string,
  path: string
): Promise<void> => {
  try {
    logger.info('üîÑ –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –≤–µ–±—Ö—É–∫...', {
      description: 'Deleting old webhook',
      webhookUrl,
      path,
    })

    await bot.telegram.deleteWebhook({ drop_pending_updates: true })
    logger.info('‚úÖ –°—Ç–∞—Ä—ã–π –≤–µ–±—Ö—É–∫ —É–¥–∞–ª–µ–Ω', {
      description: 'Old webhook deleted',
    })

    // –ñ–¥–µ–º 3 —Å–µ–∫—É–Ω–¥—ã –ø–µ—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –Ω–æ–≤–æ–≥–æ –≤–µ–±—Ö—É–∫–∞
    await new Promise(resolve => setTimeout(resolve, 3000))

    logger.info('üîÑ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –≤–µ–±—Ö—É–∫...', {
      description: 'Setting up new webhook',
      webhookUrl,
      path,
    })

    await bot.launch({
      webhook: {
        domain: webhookUrl,
        port,
        path,
        secretToken: process.env.SECRET_TOKEN,
      },
    })

    logger.info('‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ —Ä–µ–∂–∏–º–µ webhook', {
      description: 'Bot launched in webhook mode',
      webhookUrl,
      path,
    })

    return
  } catch (e) {
    logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ production —Ä–µ–∂–∏–º–∞:', {
      description: 'Error in production setup',
      error: e instanceof Error ? e.message : String(e),
    })
    throw e
  }
}

const development = async (bot: Telegraf<MyContext>): Promise<void> => {
  try {
    logger.info('üîÑ –£–¥–∞–ª—è–µ–º –≤–µ–±—Ö—É–∫ –¥–ª—è development —Ä–µ–∂–∏–º–∞...', {
      description: 'Deleting webhook for development mode',
    })

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º webhook
    const webhookInfo = await bot.telegram.getWebhookInfo()

    if (webhookInfo.url) {
      logger.info('üì° –û–±–Ω–∞—Ä—É–∂–µ–Ω –∞–∫—Ç–∏–≤–Ω—ã–π webhook:', {
        description: 'Active webhook detected',
        url: webhookInfo.url,
        has_custom_certificate: webhookInfo.has_custom_certificate,
        pending_update_count: webhookInfo.pending_update_count,
      })
    }

    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª—è–µ–º webhook —Å –æ–ø—Ü–∏–µ–π drop_pending_updates
    await bot.telegram.deleteWebhook({ drop_pending_updates: true })

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è webhook
    const webhookInfoAfter = await bot.telegram.getWebhookInfo()

    if (webhookInfoAfter.url) {
      logger.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–∏—Ç—å webhook:', {
        description: 'Failed to completely remove webhook',
        url: webhookInfoAfter.url,
      })

      // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è
      await bot.telegram.deleteWebhook({ drop_pending_updates: true })

      // –î–∞–µ–º Telegram API –≤—Ä–µ–º—è –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É –∑–∞–ø—Ä–æ—Å–∞
      await new Promise(resolve => setTimeout(resolve, 3000))
    } else {
      logger.info('‚úÖ –í–µ–±—Ö—É–∫ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', {
        description: 'Webhook successfully deleted',
      })
    }

    // –ñ–¥–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º polling
    await new Promise(resolve => setTimeout(resolve, 2000))

    logger.info('üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ –≤ —Ä–µ–∂–∏–º–µ polling...', {
      description: 'Starting bot in polling mode',
    })

    await bot.launch()

    logger.info('‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –≤ —Ä–µ–∂–∏–º–µ polling', {
      description: 'Bot launched in polling mode',
    })

    return
  } catch (e) {
    logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ development —Ä–µ–∂–∏–º–∞:', {
      description: 'Error in development setup',
      error: e instanceof Error ? e.message : String(e),
    })
    throw e
  }
}

export { production, development }
