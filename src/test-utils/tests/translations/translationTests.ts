import { TestResult } from '../../core/types'
import { supabase } from '@/core/supabase'
import { ModeEnum } from '@/types/modes'
import { logger } from '@/utils/logger'
import { readFileSync, readdirSync } from 'fs'
import { join, resolve } from 'path'
import { TestCategory } from '../../core/categories'

const REQUIRED_LANGUAGES = ['ru', 'en']
const REQUIRED_BOTS = [
  'neuro_blogger_bot',
  'clip_maker_neuro_bot',
  'ai_koshey_bot',
  'Gaia_Kamskaia_bot',
  'LeeSolarbot',
  'MetaMuse_Manifest_bot',
  'NeuroLenaAssistant_bot',
  'NeurostylistShtogrina_bot',
  'ZavaraBot',
]

// –í—Å–µ –∫–ª—é—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏
const REQUIRED_TRANSLATION_KEYS = [
  // –û–±—â–∏–µ –∫–ª—é—á–∏
  'help',
  'start',
  'cancel',
  'error',
  'success',

  // –°–∏—Å—Ç–µ–º–Ω—ã–µ –∫–ª—é—á–∏
  'maintenance',
  'rate_limit',
  'subscription_required',

  // –ö–ª—é—á–∏ –¥–ª—è —Å—Ü–µ–Ω –∏ —Ä–µ–∂–∏–º–æ–≤
  'subscriptionScene',
  'digitalAvatar',
  'chat_with_avatar_start',
  'avatar_brain_description',
  'avatar_voice_description',
  'avatar_model_description',
  'avatar_greeting',
  'avatar_help',

  // –ö–ª—é—á–∏ –∏–∑ ModeEnum
  ModeEnum.Subscribe,
  ModeEnum.DigitalAvatarBody,
  ModeEnum.NeuroPhoto,
  ModeEnum.ImageToPrompt,
  ModeEnum.Avatar,
  ModeEnum.ChatWithAvatar,
  ModeEnum.SelectModel,
  ModeEnum.Voice,
  ModeEnum.TextToSpeech,
  ModeEnum.ImageToVideo,
  ModeEnum.TextToVideo,
  ModeEnum.TextToImage,
]

interface MissingTranslation {
  bot: string
  key: string
  language: string
}

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ø—É—Ç–µ–π –∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
const LOCALES_PATH = resolve(process.cwd(), 'locales')
const REQUIRED_KEYS = [
  'common',
  'chats',
  'features',
  'bot',
  'errors',
  'userBotChat',
  'userServerChat',
]

// –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ø—É—Ç—å –∫ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è–º, —É—á–∏—Ç—ã–≤–∞—è –≤–æ–∑–º–æ–∂–Ω—ã–π –∑–∞–ø—É—Å–∫ –∏–∑ src/
const LOCALIZATIONS_PATH = (() => {
  const basePath = process.cwd()
  const relativePath = 'localizations'
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏–º—Å—è –ª–∏ –º—ã –≤ 'src'
  if (basePath.endsWith('/src')) {
    return resolve(basePath, relativePath)
  }
  
  // –ò–Ω–∞—á–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω—ã–π –ø—É—Ç—å —Å /src/
  return resolve(basePath, 'src', relativePath)
})()

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–µ—Ä–µ–≤–æ–¥—ã –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞
 * @param language —è–∑—ã–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
 * @returns —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 */
export function checkLocalizationFiles(language: string): TestResult {
  logger.info(`Checking ${language} translations...`)
  
  try {
    const langPath = join(LOCALIZATIONS_PATH, language)
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å –ø–µ—Ä–µ–≤–æ–¥–∞–º–∏
    try {
      readdirSync(langPath)
    } catch (e) {
      return {
        name: `${language} translations check`,
        success: false,
        message: `Directory for ${language} translations not found at ${langPath}`,
        category: TestCategory.Translations
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –ø–µ—Ä–µ–≤–æ–¥–æ–≤
    for (const key of REQUIRED_KEYS) {
      const filePath = join(langPath, `${key}.json`)
      try {
        readFileSync(filePath, 'utf8')
      } catch (e) {
        return {
          name: `${language} translations check`,
          success: false,
          message: `Required translation file ${key}.json not found for ${language}`,
          category: TestCategory.Translations
        }
      }
    }
    
    return {
      name: `${language} translations check`,
      success: true,
      message: `All required ${language} translation files exist`,
      category: TestCategory.Translations
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    logger.error(`Error checking ${language} translations:`, errorMessage)
    return {
      name: `${language} translations check`,
      success: false,
      message: `Error checking ${language} translations: ${errorMessage}`,
      category: TestCategory.Translations
    }
  }
}

/**
 * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç —Ä—É—Å—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã
 * @returns —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 */
export function testRussianTranslations(): TestResult {
  logger.info('Starting Russian translations test...')
  return checkLocalizationFiles('ru')
}

/**
 * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ –ø–µ—Ä–µ–≤–æ–¥—ã
 * @returns —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 */
export function testEnglishTranslations(): TestResult {
  logger.info('Starting English translations test...')
  return checkLocalizationFiles('en')
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å –∫–ª—é—á–µ–π –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –º–µ–∂–¥—É —Ä—É—Å—Å–∫–∏–º –∏ –∞–Ω–≥–ª–∏–π—Å–∫–∏–º —è–∑—ã–∫–∞–º–∏
 * @returns —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
 */
export function testLocalizationKeysConsistency(): TestResult {
  logger.info('Checking localization keys consistency...')
  
  try {
    const results: {[key: string]: {ru: object, en: object}} = {}
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –ø–µ—Ä–µ–≤–æ–¥–æ–≤
    for (const key of REQUIRED_KEYS) {
      results[key] = { ru: {}, en: {} }
      
      for (const lang of REQUIRED_LANGUAGES) {
        const filePath = join(LOCALIZATIONS_PATH, lang, `${key}.json`)
        try {
          const content = readFileSync(filePath, 'utf8')
          results[key][lang as 'ru' | 'en'] = JSON.parse(content)
        } catch (e: unknown) {
          const errorMessage = e instanceof Error ? e.message : String(e)
          return {
            name: 'Localization keys consistency check',
            success: false,
            message: `Could not read or parse ${lang}/${key}.json file: ${errorMessage}`,
            category: TestCategory.Translations
          }
        }
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å –∫–ª—é—á–µ–π
    const missingKeys: string[] = []
    
    for (const fileKey of REQUIRED_KEYS) {
      const ruKeys = Object.keys(results[fileKey].ru)
      const enKeys = Object.keys(results[fileKey].en)
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –∫–ª—é—á–∏ –∏–∑ —Ä—É—Å—Å–∫–æ–π –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –µ—Å—Ç—å –≤ –∞–Ω–≥–ª–∏–π—Å–∫–æ–π
      for (const key of ruKeys) {
        if (!enKeys.includes(key)) {
          missingKeys.push(`Missing in EN: ${fileKey}.${key}`)
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –∫–ª—é—á–∏ –∏–∑ –∞–Ω–≥–ª–∏–π—Å–∫–æ–π –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –µ—Å—Ç—å –≤ —Ä—É—Å—Å–∫–æ–π
      for (const key of enKeys) {
        if (!ruKeys.includes(key)) {
          missingKeys.push(`Missing in RU: ${fileKey}.${key}`)
        }
      }
    }
    
    if (missingKeys.length > 0) {
      return {
        name: 'Localization keys consistency check',
        success: false,
        message: `Found ${missingKeys.length} inconsistent localization keys:\n${missingKeys.join('\n')}`,
        category: TestCategory.Translations
      }
    }
    
    return {
      name: 'Localization keys consistency check',
      success: true,
      message: 'All localization keys are consistent between Russian and English translations',
      category: TestCategory.Translations
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    logger.error('Error checking localization keys consistency:', errorMessage)
    return {
      name: 'Localization keys consistency check',
      success: false,
      message: `Error checking localization keys consistency: ${errorMessage}`,
      category: TestCategory.Translations
    }
  }
}

/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏ –∫–ª—é—á–µ–π
 */
export function checkTranslations(): TestResult {
  try {
    logger.info({
      message: 'üß™ –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏',
      description: 'Running localization tests'
    })

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ locales
    if (!readdirSync(LOCALES_PATH)) {
      throw new Error(`–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è ${LOCALES_PATH} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞`)
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —è–∑—ã–∫
    for (const lang of REQUIRED_LANGUAGES) {
      const langPath = join(LOCALES_PATH, lang)
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —è–∑—ã–∫–∞
      try {
        readdirSync(langPath)
      } catch (error) {
        throw new Error(`–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —è–∑—ã–∫–∞ "${lang}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ ${langPath}`)
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–≥–æ –±–æ—Ç–∞
      for (const bot of REQUIRED_BOTS) {
        const botPath = join(langPath, bot)
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –±–æ—Ç–∞
        try {
          readdirSync(botPath)
        } catch (error) {
          throw new Error(`–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –±–æ—Ç–∞ "${bot}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ ${botPath}`)
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –∫–ª—é—á–µ–π
        for (const key of REQUIRED_KEYS) {
          const keyPath = join(botPath, `${key}.json`)
          
          try {
            // –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∏ —Å–ø–∞—Ä—Å–∏—Ç—å —Ñ–∞–π–ª –ø–µ—Ä–µ–≤–æ–¥–∞
            const translationFile = readFileSync(keyPath, 'utf-8')
            JSON.parse(translationFile)
          } catch (error) {
            throw new Error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∏–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: ${keyPath}`)
          }
        }
      }
    }

    return {
      name: 'Translation files check',
      success: true,
      message: '–í—Å–µ —Ñ–∞–π–ª—ã –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞–π–¥–µ–Ω—ã –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã',
      category: TestCategory.Translations
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error)
    
    logger.error({
      message: '‚ùå –û—à–∏–±–∫–∞ –≤ —Ç–µ—Å—Ç–∞—Ö –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏',
      description: 'Localization test failed',
      error: errorMessage
    })
    
    return {
      name: 'Translation files check',
      success: false,
      message: errorMessage,
      category: TestCategory.Translations
    }
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–ª–Ω–æ—Ç—É –ø–µ—Ä–µ–≤–æ–¥–∞ –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏
 */
function validateTranslationCompleteness(obj: any, path: string, lang: string): void {
  if (typeof obj === 'object' && obj !== null) {
    Object.entries(obj).forEach(([key, value]) => {
      const currentPath = path ? `${path}.${key}` : key
      
      if (typeof value === 'object' && value !== null) {
        validateTranslationCompleteness(value, currentPath, lang)
      } else if (value === '' || value === null || value === undefined) {
        throw new Error(`–ü—É—Å—Ç–æ–π –ø–µ—Ä–µ–≤–æ–¥ –¥–ª—è –∫–ª—é—á–∞ "${currentPath}" –≤ —è–∑—ã–∫–µ "${lang}"`)
      }
    })
  }
}

/**
 * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Å–µ –∫–ª—é—á–∏ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞
 */
function extractAllTranslationKeys(lang: string): string[] {
  const allKeys: string[] = []
  const langPath = join(LOCALES_PATH, lang)
  
  for (const bot of REQUIRED_BOTS) {
    const botPath = join(langPath, bot)
    
    for (const key of REQUIRED_KEYS) {
      const keyPath = join(botPath, `${key}.json`)
      
      try {
        const translationFile = readFileSync(keyPath, 'utf-8')
        const translationData = JSON.parse(translationFile)
        
        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –ø—É—Ç–∏ –∫–ª—é—á–µ–π –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
        const keyPaths = extractKeyPaths(translationData, `${bot}.${key}`)
        allKeys.push(...keyPaths)
      } catch (error) {
        throw new Error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∫–ª—é—á–µ–π –∏–∑ —Ñ–∞–π–ª–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: ${keyPath}`)
      }
    }
  }
  
  return allKeys
}

/**
 * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Å–µ –ø—É—Ç–∏ –∫–ª—é—á–µ–π –∏–∑ –æ–±—ä–µ–∫—Ç–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
 */
function extractKeyPaths(obj: any, basePath: string = ''): string[] {
  let paths: string[] = []
  
  if (typeof obj === 'object' && obj !== null) {
    Object.entries(obj).forEach(([key, value]) => {
      const currentPath = basePath ? `${basePath}.${key}` : key
      
      if (typeof value === 'object' && value !== null) {
        paths = paths.concat(extractKeyPaths(value, currentPath))
      } else {
        paths.push(currentPath)
      }
    })
  }
  
  return paths
}

/**
 * –ù–∞—Ö–æ–¥–∏—Ç –∫–ª—é—á–∏, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –≤–æ –≤—Ç–æ—Ä–æ–º –Ω–∞–±–æ—Ä–µ
 */
function findMissingKeys(sourceKeys: string[], targetKeys: string[]): string[] {
  return sourceKeys.filter(key => !targetKeys.includes(key))
}
