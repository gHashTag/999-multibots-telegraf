import { Markup, Scenes } from 'telegraf'
import { MyContext } from '../../interfaces'
import { setPayments } from '../../core/supabase'
import { isRussian } from '@/helpers'
import { paymentOptions } from '@/price/priceCalculator'
import md5 from 'md5'
import { MERCHANT_LOGIN, PASSWORD1, RESULT_URL2 } from '@/config'
import { handleHelpCancel } from '@/handlers'
import { getBotNameByToken } from '@/core'
import { ModeEnum } from '@/price/helpers/modelsCost'
const merchantLogin = MERCHANT_LOGIN
const password1 = PASSWORD1

const description = '–ü–æ–∫—É–ø–∫–∞ –∑–≤–µ–∑–¥'

const resultUrl2 = RESULT_URL2

function generateRobokassaUrl(
  merchantLogin: string,
  outSum: number,
  invId: number,
  description: string,
  password1: string
): string {
  const signatureValue = md5(
    `${merchantLogin}:${outSum}:${invId}:${encodeURIComponent(
      resultUrl2
    )}:${password1}`
  ).toUpperCase()
  const url = `https://auth.robokassa.ru/Merchant/Index.aspx?MerchantLogin=${merchantLogin}&OutSum=${outSum}&InvId=${invId}&Description=${encodeURIComponent(
    description
  )}&SignatureValue=${signatureValue}&ResultUrl2=${encodeURIComponent(
    resultUrl2
  )}`

  return url
}

async function getInvoiceId(
  merchantLogin: string,
  outSum: number,
  invId: number,
  description: string,
  password1: string
): Promise<string> {
  console.log('Start getInvoiceId', {
    merchantLogin,
    outSum,
    invId,
    description,
    password1,
  })
  try {
    const response = generateRobokassaUrl(
      merchantLogin,
      outSum,
      invId,
      description,
      password1
    )

    return response
  } catch (error) {
    console.error('Error in getInvoiceId:', error)
    throw error
  }
}

export const emailWizard = new Scenes.BaseScene<MyContext>(ModeEnum.EmailWizard)

emailWizard.enter(async ctx => {
  const isRu = isRussian(ctx)

  if (!ctx.from) {
    throw new Error('User not found')
  }

  const buttons = paymentOptions.map(option => [
    isRu
      ? `–ö—É–ø–∏—Ç—å ${option.stars}‚≠êÔ∏è –∑–∞ ${option.amount} —Ä`
      : `Buy ${option.stars}‚≠êÔ∏è for ${option.amount} RUB`,
  ])

  const keyboard = Markup.keyboard(buttons).resize()

  await ctx.reply(
    isRu ? '–í—ã–±–µ—Ä–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –æ–ø–ª–∞—Ç—ã:' : 'Choose the amount for payment:',
    {
      reply_markup: keyboard.reply_markup,
    }
  )
})

emailWizard.on('text', async ctx => {
  const isRu = isRussian(ctx)
  const msg = ctx.message

  if (msg && 'text' in msg) {
    const selectedOption = msg.text

    const isCancel = await handleHelpCancel(ctx)
    if (isCancel) {
      return ctx.scene.leave()
    }

    const match = isRu
      ? selectedOption.match(/–ö—É–ø–∏—Ç—å (\d+)‚≠êÔ∏è –∑–∞ (\d+) —Ä/)
      : selectedOption.match(/Buy (\d+)‚≠êÔ∏è for (\d+) RUB/)

    if (match) {
      const stars = parseInt(match[1], 10) // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥
      const amount = parseInt(match[2], 10) // –°—É–º–º–∞ –≤ —Ä—É–±–ª—è—Ö

      try {
        const userId = ctx.from?.id
        const invId = Math.floor(Math.random() * 1000000)
        // –ü–æ–ª—É—á–µ–Ω–∏–µ invoiceID
        const invoiceURL = await getInvoiceId(
          merchantLogin,
          amount,
          invId,
          description,
          password1
        )
        const email = ctx.session.email

        const { bot_name } = getBotNameByToken(ctx.telegram.token)

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º PENDING
        await setPayments({
          telegram_id: userId.toString(),
          OutSum: amount.toString(),
          InvId: invId.toString(),
          currency: 'RUB',
          stars,
          status: 'PENDING',
          email: email,
          payment_method: 'Telegram',
          subscription: 'stars',
          bot_name,
          language: ctx.from?.language_code,
          invoice_url: invoiceURL,
        })

        console.log('invoiceURL', invoiceURL)

        const inlineKeyboard = [
          [
            {
              text: isRu
                ? `–ö—É–ø–∏—Ç—å ${stars}‚≠êÔ∏è –∑–∞ ${amount} —Ä`
                : `Buy ${stars}‚≠êÔ∏è for ${amount} RUB`,
              url: invoiceURL,
            },
          ],
          [
            {
              text: isRu ? '–ß—Ç–æ —Ç–∞–∫–æ–µ –∑–≤–µ–∑–¥—ã‚ùì' : 'What are stars‚ùì',
              web_app: {
                url: `https://telegram.org/blog/telegram-stars/${
                  isRu ? 'ru' : 'en'
                }?ln=a`,
              },
            },
          ],
        ]

        await ctx.reply(
          isRu
            ? `<b>üíµ –ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞</b>
–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å –Ω–∞ –ª—é–±–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥ –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –±–æ—Ç–∞.\n–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞ —Å–≤–æ–π –±–∞–ª–∞–Ω—Å.\n–í —Å–ª—É—á–∞–µ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å –æ–ø–ª–∞—Ç–æ–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏ @neuro_sage`
            : `<b>üíµ Balance Top-Up</b>
You can now top up your balance with any number of stars and use them for various bot features. Simply choose the number of stars you want to add to your balance.\nIn case of payment issues, please contact us @neuro_sage`,
          {
            reply_markup: {
              inline_keyboard: inlineKeyboard,
            },
            parse_mode: 'HTML',
          }
        )
      } catch (error) {
        console.error('Error in creating payment:', error)
        await ctx.reply(
          isRu
            ? '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —á–µ–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.'
            : 'Error creating invoice. Please try again.'
        )
      }
      return ctx.scene.leave()
    } else {
      await ctx.reply(
        isRu
          ? '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É.'
          : 'Please select a valid amount.'
      )
    }
  }
})

export default emailWizard
