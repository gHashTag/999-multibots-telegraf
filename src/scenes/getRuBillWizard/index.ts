import { MyContext } from '@/interfaces/telegram-bot.interface'
import { isRussian } from '@/helpers'
import {
  getInvoiceId,
  merchantLogin,
  password1,
  description,
  subscriptionTitles,
  useTestMode,
  generateShortInvId,
} from './helper'
import { updateUserSubscription } from '@/core/supabase'
import { WizardScene } from 'telegraf/scenes'
import { getBotNameByToken } from '@/core'
import { TransactionType } from '@/interfaces/payments.interface'
import { logger } from '@/utils/logger'
import { inngest } from '@/inngest-functions/clients'
import { ModeEnum } from '@/interfaces/modes'

type Subscription = 'neurophoto' | 'neurobase' | 'neuroblogger'

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–∏–ø –¥–ª—è –ø–æ–¥–ø–∏—Å–æ–∫
export type LocalSubscription = Extract<
  Subscription,
  'neurophoto' | 'neurobase' | 'neuroblogger'
>

const generateInvoiceStep = async (ctx: MyContext) => {
  logger.info('üöÄ –ù–∞—á–∞–ª–æ —Å–æ–∑–¥–∞–Ω–∏—è —Å—á–µ—Ç–∞', {
    description: 'Starting invoice generation',
  })

  const isRu = isRussian(ctx)
  const selectedPayment = ctx.session.selectedPayment

  if (!selectedPayment) {
    logger.error('‚ùå –ù–µ –≤—ã–±—Ä–∞–Ω —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã', {
      description: 'Payment method not selected',
    })
    return
  }

  const email = ctx.session.email
  logger.info('üìß Email –ø–æ–ª—É—á–µ–Ω –∏–∑ —Å–µ—Å—Å–∏–∏:', {
    description: 'Email from session',
    email,
  })

  const stars = selectedPayment.amount
  const subscription = selectedPayment.subscription as Subscription | undefined

  try {
    const userId = ctx.from?.id
    if (!userId) {
      throw new Error('User ID not found')
    }

    logger.info('üë§ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', {
      description: 'User ID',
      userId,
    })

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ—Ä–æ—Ç–∫–∏–π InvId –¥–ª—è Robokassa
    const numericInvId = await generateShortInvId(userId, stars)
    const invId = numericInvId.toString()

    logger.info('üî¢ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω ID —Å—á–µ—Ç–∞:', {
      description: 'Generated invoice ID',
      invId,
      numericInvId,
    })
    if (!merchantLogin || !password1) {
      throw new Error('merchantLogin or password1 is not defined')
    }

    // –ü–æ–ª—É—á–µ–Ω–∏–µ invoiceID
    const invoiceURL = await getInvoiceId(
      merchantLogin,
      stars,
      numericInvId,
      description,
      password1,
      useTestMode
    )
    logger.info('üîó URL —Å—á–µ—Ç–∞:', {
      description: 'Invoice URL',
      invoiceURL,
    })

    const { bot_name } = getBotNameByToken(ctx.telegram.token)

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞
    logger.info('‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞ –≤ RuBillWizard:', {
      description: 'Processing payment in RuBillWizard',
      telegram_id: userId,
      amount: stars,
      inv_id: invId,
    })

    await inngest.send({
      name: 'payment/process',
      data: {
        telegram_id: String(userId),
        amount: Number(stars),
        type: TransactionType.MONEY_INCOME,
        description: subscription
          ? `–ü–æ–∫—É–ø–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ ${subscription}`
          : `–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –Ω–∞ ${stars} –∑–≤–µ–∑–¥`,
        bot_name,
        inv_id: invId,
        stars: Number(stars),
        payment_method: 'Telegram',
        subscription: subscription,
        currency: 'RUB',
        invoice_url: invoiceURL,
        service_type: subscription ? ModeEnum.Subscribe : ModeEnum.TopUpBalance,
        status: 'PENDING',
      },
    })

    // –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π –æ–ø–ª–∞—Ç—ã
    const titles = subscriptionTitles(isRu)
    const subscriptionTitle = subscription ? titles[subscription] : ''

    const inlineKeyboard = [
      [
        {
          text: isRu ? '–û–ø–ª–∞—Ç–∏—Ç—å' : 'Pay',
          url: invoiceURL,
        },
      ],
    ]

    const messageText = isRu
      ? `<b>üí≥ ${subscription ? `–ü–æ–¥–ø–∏—Å–∫–∞ ${subscriptionTitle}` : '–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞'}</b>\n` +
        `<b>üí∞ –°—É–º–º–∞:</b> ${stars} ‚ÇΩ\n` +
        `<i>–ü—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å –æ–ø–ª–∞—Ç–æ–π: @neuro_sage</i>`
      : `<b>üí≥ ${subscription ? `Subscription ${subscriptionTitle}` : 'Balance top-up'}</b>\n` +
        `<b>üí∞ Amount:</b> ${stars} RUB\n` +
        `<i>Payment support: @neuro_sage</i>`

    await ctx.reply(messageText, {
      reply_markup: {
        inline_keyboard: inlineKeyboard,
      },
      parse_mode: 'HTML',
    })
    logger.info('‚úâÔ∏è –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–ø–ª–∞—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é', {
      description: 'Payment message sent to user',
    })

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if (subscription) {
      await updateUserSubscription(userId.toString(), subscription)
      logger.info('‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞', {
        description: 'User subscription updated',
      })
    }

    ctx.session.selectedPayment = {
      amount: selectedPayment.amount,
      stars: Number(selectedPayment.stars),
      subscription: selectedPayment.subscription as LocalSubscription,
      type: TransactionType.SUBSCRIPTION_PURCHASE,
    }

    return ctx.scene.leave()
  } catch (error) {
    logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—á–µ—Ç–∞:', {
      description: 'Error creating invoice',
      error: error instanceof Error ? error.message : String(error),
    })
    await ctx.reply(
      isRu
        ? '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —á–µ–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.'
        : 'Error creating invoice. Please try again.'
    )
    ctx.scene.leave()
    return
  }
}

export const getRuBillWizard = new WizardScene(
  'getRuBillWizard',
  generateInvoiceStep
)
