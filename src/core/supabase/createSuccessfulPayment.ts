import { TelegramId } from '@/interfaces/telegram.interface'
import { TransactionType } from '@/interfaces/payments.interface'
import { SubscriptionType } from '@/interfaces/subscription.interface'
import { supabase } from '@/supabase'
import { getUserByTelegramId } from './getUserByTelegramId'
import { normalizeTransactionType } from '@/utils/service.utils'
import { logger } from '@/utils/logger'

interface CreateSuccessfulPaymentParams {
  telegram_id: TelegramId
  amount: number
  type: TransactionType | string
  description: string
  bot_name: string
  service_type?: string
  payment_method?: string
  metadata?: Record<string, any>
  subscription?: SubscriptionType
  inv_id: string
  stars?: number
  status?: string
  currency?: string
  invoice_url?: string
}

/**
 * –°–æ–∑–¥–∞–µ—Ç —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂ –≤ —Å–∏—Å—Ç–µ–º–µ
 * @param params –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–ª–∞—Ç–µ–∂–∞
 * @returns –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞
 */
export async function createSuccessfulPayment({
  telegram_id,
  amount,
  type,
  description,
  service_type,
  stars,
  payment_method = 'Telegram',
  bot_name,
  metadata,
  status = 'COMPLETED',
  inv_id,
  currency = 'XTR',
  invoice_url,
  subscription,
}: CreateSuccessfulPaymentParams) {
  try {
    // –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω inv_id, –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –ø–ª–∞—Ç–µ–∂ —Å —Ç–∞–∫–∏–º ID
    if (inv_id) {
      const { data: existingPayment } = await supabase
        .from('payments_v2')
        .select('id, inv_id')
        .eq('inv_id', inv_id)
        .maybeSingle()

      if (existingPayment) {
        logger.info('üîÑ [–î–£–ë–õ–ò–ö–ê–¢]: –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–ª–∞—Ç–µ–∂ —Å —Ç–µ–º –∂–µ inv_id:', {
          description:
            'Attempt to create payment with existing inv_id (duplicate prevented)',
          inv_id,
          existing_payment_id: existingPayment.id,
        })

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π –ø–ª–∞—Ç–µ–∂, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
        const { data: paymentData } = await supabase
          .from('payments_v2')
          .select('*')
          .eq('id', existingPayment.id)
          .single()

        logger.info(
          '‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–ª–∞—Ç–µ–∂ –≤–º–µ—Å—Ç–æ —Å–æ–∑–¥–∞–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–∞:',
          {
            description:
              'Returning existing payment instead of creating duplicate',
            payment_id: existingPayment.id,
            inv_id,
          }
        )

        return paymentData
      }
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    const user = await getUserByTelegramId(telegram_id)
    if (!user) {
      throw new Error(`User not found for telegram_id: ${telegram_id}`)
    }

    // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏
    const params = {
      telegram_id,
      amount,
      type,
      description,
      service_type,
      stars,
      payment_method,
      bot_name,
      metadata,
      status,
      inv_id,
      currency,
      invoice_url,
      subscription,
    }

    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Ç–∏–ø —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ –Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –ë–î
    params.type = normalizeTransactionType(type as TransactionType)

    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º telegram_id –∫ —Å—Ç—Ä–æ–∫–µ
    const telegramIdStr = String(telegram_id)

    const numericStars = stars !== undefined ? Number(stars) : amount

    const { data, error } = await supabase
      .from('payments_v2')
      .insert({
        telegram_id: telegramIdStr,
        amount,
        stars: numericStars,
        payment_method,
        description,
        type: params.type,
        service_type,
        bot_name,
        status,
        metadata,
        currency,
        inv_id,
        invoice_url,
        subscription,
      })
      .select()
      .single()

    if (error) {
      // –î–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è inv_id
      if (
        error &&
        typeof error === 'object' &&
        'code' in error &&
        error.code === '23505'
      ) {
        logger.info('üîÑ [–î–£–ë–õ–ò–ö–ê–¢]: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞:', {
          description:
            'Duplicate payment prevented (unique constraint violation)',
          error: error instanceof Error ? error.message : String(error),
          code: error.code,
          details: 'details' in error ? error.details : 'Unknown details',
        })
      }
      // –î–ª—è –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      else if (
        error instanceof Error &&
        error.message.includes('User not found')
      ) {
        logger.info('üë§ [–ü–†–û–í–ï–†–ö–ê]: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω:', {
          description: 'User not found check (expected in some test cases)',
          error: error.message,
        })
      }
      // –î–ª—è –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫
      else {
        logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–ø–∏—Å–∏ –æ –ø–ª–∞—Ç–µ–∂–µ:', {
          description: 'Error creating payment record',
          error: error instanceof Error ? error.message : String(error),
          error_details: error,
          telegram_id,
          amount,
          type,
          bot_name,
        })
      }
      throw error
    }

    logger.info('‚úÖ –ó–∞–ø–∏—Å—å –æ –ø–ª–∞—Ç–µ–∂–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞:', {
      description: 'Payment record created successfully',
      payment_id: data.id,
      telegram_id,
      amount,
      type: params.type,
      bot_name,
    })

    return data
  } catch (error) {
    // –î–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è inv_id
    if (
      error &&
      typeof error === 'object' &&
      'code' in error &&
      error.code === '23505'
    ) {
      logger.info('üîÑ [–î–£–ë–õ–ò–ö–ê–¢]: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–æ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞:', {
        description:
          'Duplicate payment prevented (unique constraint violation)',
        error: error instanceof Error ? error.message : String(error),
        code: error.code,
        details: 'details' in error ? error.details : 'Unknown details',
      })
    }
    // –î–ª—è –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    else if (
      error instanceof Error &&
      error.message.includes('User not found')
    ) {
      logger.info('üë§ [–ü–†–û–í–ï–†–ö–ê]: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω:', {
        description: 'User not found check (expected in some test cases)',
        error: error.message,
      })
    }
    // –î–ª—è –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫
    else {
      logger.error('‚ùå –û—à–∏–±–∫–∞ –≤ createSuccessfulPayment:', {
        description: 'Error in createSuccessfulPayment function',
        error: error instanceof Error ? error.message : String(error),
        error_details: error,
      })
    }
    throw error
  }
}
