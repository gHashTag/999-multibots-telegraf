import axios, { AxiosInstance } from 'axios'
import { ZEP_CONFIG, ZepMemory } from '@/config/zep'
import { logger } from '@/utils/logger'
import { Cache } from '@/core/cache'

interface ZepMessage {
  role: 'user' | 'assistant'
  content: string
  timestamp: number
}

interface ZepMetrics {
  cacheSize: number
  hitRate: number
  missRate: number
}

export interface IZepClient {
  getMemory(sessionId: string): Promise<ZepMemory | null>
  saveMemory(sessionId: string, memory: ZepMemory): Promise<void>
  addMessage(sessionId: string, role: 'user' | 'assistant', content: string): Promise<void>
  clearMemory(sessionId: string): Promise<void>
  getMetrics(): ZepMetrics
  destroy(): void
}

export class ZepClient implements IZepClient {
  private static instance: ZepClient
  private client: AxiosInstance
  private cache: Cache<ZepMemory>

  private constructor() {
    this.client = axios.create({
      baseURL: ZEP_CONFIG.baseUrl,
      headers: {
        'Authorization': `Bearer ${ZEP_CONFIG.apiKey}`,
        'Content-Type': 'application/json',
      },
    })
    this.cache = new Cache<ZepMemory>()

    logger.info('üöÄ ZepClient –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω:', {
      description: 'ZepClient initialized with cache'
    })
  }

  public static getInstance(): ZepClient {
    if (!ZepClient.instance) {
      ZepClient.instance = new ZepClient()
    }
    return ZepClient.instance
  }

  async getMemory(sessionId: string): Promise<ZepMemory | null> {
    try {
      // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫—ç—à–∞
      const cachedMemory = this.cache.get(sessionId)
      if (cachedMemory) {
        logger.info('üìù –ü–∞–º—è—Ç—å –ø–æ–ª—É—á–µ–Ω–∞ –∏–∑ –∫—ç—à–∞:', {
          description: 'Memory retrieved from cache',
          sessionId
        })
        return cachedMemory
      }

      // –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫—ç—à–µ, –ø–æ–ª—É—á–∞–µ–º –∏–∑ API
      const response = await this.client.get(`/memory/${sessionId}`)
      const memory = response.data

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
      this.cache.set(sessionId, memory)

      logger.info('üìù –ü–∞–º—è—Ç—å –ø–æ–ª—É—á–µ–Ω–∞ –∏–∑ ZEP:', {
        description: 'Memory retrieved from ZEP',
        sessionId
      })
      return memory
    } catch (error) {
      logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–∞–º—è—Ç–∏:', {
        description: 'Error retrieving memory',
        error: error instanceof Error ? error.message : String(error),
        sessionId
      })
      return null
    }
  }

  async saveMemory(sessionId: string, memory: ZepMemory): Promise<void> {
    try {
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ API
      await this.client.post(`/memory/${sessionId}`, memory)
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
      this.cache.set(sessionId, memory)

      logger.info('üíæ –ü–∞–º—è—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞:', {
        description: 'Memory saved',
        sessionId
      })
    } catch (error) {
      logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–∞–º—è—Ç–∏:', {
        description: 'Error saving memory',
        error: error instanceof Error ? error.message : String(error),
        sessionId
      })
    }
  }

  async addMessage(sessionId: string, role: 'user' | 'assistant', content: string): Promise<void> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–∞–º—è—Ç—å (—Å–Ω–∞—á–∞–ª–∞ –∏–∑ –∫—ç—à–∞)
      const memory = await this.getMemory(sessionId) || { messages: [] }
      
      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
      memory.messages.push({
        role,
        content,
        timestamp: Date.now(),
      })

      // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π
      if (memory.messages.length > ZEP_CONFIG.memoryWindow) {
        memory.messages = memory.messages.slice(-ZEP_CONFIG.memoryWindow)
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –ø–∞–º—è—Ç—å
      await this.saveMemory(sessionId, memory)

      logger.info('üì® –°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –ø–∞–º—è—Ç—å:', {
        description: 'Message added to memory',
        sessionId,
        role,
        messageCount: memory.messages.length
      })
    } catch (error) {
      logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', {
        description: 'Error adding message',
        error: error instanceof Error ? error.message : String(error),
        sessionId
      })
    }
  }

  async clearMemory(sessionId: string): Promise<void> {
    try {
      // –û—á–∏—â–∞–µ–º –≤ API
      await this.client.delete(`/memory/${sessionId}`)
      
      // –û—á–∏—â–∞–µ–º –∫—ç—à
      this.cache.delete(sessionId)

      logger.info('üßπ –ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞:', {
        description: 'Memory cleared',
        sessionId
      })
    } catch (error) {
      logger.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –ø–∞–º—è—Ç–∏:', {
        description: 'Error clearing memory',
        error: error instanceof Error ? error.message : String(error),
        sessionId
      })
    }
  }

  public getMetrics(): ZepMetrics {
    const metrics = this.cache.getMetrics()
    return {
      cacheSize: metrics.size,
      hitRate: metrics.hitRate,
      missRate: metrics.missRate
    }
  }

  public destroy() {
    this.cache.destroy()
  }
}