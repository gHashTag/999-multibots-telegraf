import dotenv from 'dotenv'

dotenv.config()

import { NODE_ENV } from '@/config'
import { Telegraf } from 'telegraf'
import { MyContext } from '@/interfaces'
import { logger } from '@/utils/logger'

import { getBotGroupFromAvatars } from '@/core/supabase'
if (!process.env.BOT_TOKEN_1) throw new Error('BOT_TOKEN_1 is not set')
if (!process.env.BOT_TOKEN_2) throw new Error('BOT_TOKEN_2 is not set')
if (!process.env.BOT_TOKEN_3) throw new Error('BOT_TOKEN_3 is not set')
if (!process.env.BOT_TOKEN_4) throw new Error('BOT_TOKEN_4 is not set')
if (!process.env.BOT_TOKEN_5) throw new Error('BOT_TOKEN_5 is not set')
if (!process.env.BOT_TOKEN_6) throw new Error('BOT_TOKEN_6 is not set')
if (!process.env.BOT_TOKEN_7) throw new Error('BOT_TOKEN_7 is not set')

if (!process.env.BOT_TOKEN_TEST_1)
  throw new Error('BOT_TOKEN_TEST_1 is not set')
if (!process.env.BOT_TOKEN_TEST_2)
  throw new Error('BOT_TOKEN_TEST_2 is not set')

const BOT_TOKENS_PROD = [
  process.env.BOT_TOKEN_1,
  process.env.BOT_TOKEN_2,
  process.env.BOT_TOKEN_3,
  process.env.BOT_TOKEN_4,
  process.env.BOT_TOKEN_5,
  process.env.BOT_TOKEN_6,
  process.env.BOT_TOKEN_7,
]
const BOT_TOKENS_TEST = [
  process.env.BOT_TOKEN_TEST_1,
  process.env.BOT_TOKEN_TEST_2,
]

export const BOT_NAMES = {
  ['neuro_blogger_bot']: process.env.BOT_TOKEN_1,
  ['MetaMuse_Manifest_bot']: process.env.BOT_TOKEN_2,
  ['ZavaraBot']: process.env.BOT_TOKEN_3,
  ['LeeSolarbot']: process.env.BOT_TOKEN_4,
  ['NeuroLenaAssistant_bot']: process.env.BOT_TOKEN_5,
  ['NeurostylistShtogrina_bot']: process.env.BOT_TOKEN_6,
  ['Gaia_Kamskaia_bot']: process.env.BOT_TOKEN_7,
  ['ai_koshey_bot']: process.env.BOT_TOKEN_TEST_1,
  ['clip_maker_neuro_bot']: process.env.BOT_TOKEN_TEST_2,
}

// Tutorial URLs
export const BOT_URLS = {
  MetaMuse_Manifest_bot: 'https://t.me/MetaMuse_manifestation/16',
  neuro_blogger_bot: 'https://t.me/neuro_coder_ai/1212',
  ai_koshey_bot: 'https://t.me/neuro_coder_ai/1212',
}

export const BOT_TOKENS =
  NODE_ENV === 'production' ? BOT_TOKENS_PROD : BOT_TOKENS_TEST

export const DEFAULT_BOT_TOKEN = process.env.BOT_TOKEN_1

export const DEFAULT_BOT_NAME = 'neuro_blogger_bot'
export const defaultBot = new Telegraf<MyContext>(DEFAULT_BOT_TOKEN)

export function getBotNameByToken(token: string): { bot_name: string } {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const entry = Object.entries(BOT_NAMES).find(([_, value]) => value === token)
  if (!entry) {
    return { bot_name: DEFAULT_BOT_NAME }
  }

  const [bot_name] = entry
  return { bot_name }
}

export function getTokenByBotName(botName: string): string | undefined {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const entry = Object.entries(BOT_NAMES).find(([name, _]) => name === botName)
  if (!entry) {
    console.warn(`Bot name ${botName} not found.`)
    return undefined
  }

  const [, token] = entry
  return token
}

export async function createBotByName(
  botName: string
): Promise<
  { token: string; groupId: string; bot: Telegraf<MyContext> } | undefined
> {
  const token = getTokenByBotName(botName)
  if (!token) {
    console.error(`Token for bot name ${botName} not found.`)
    return undefined
  }
  const groupId = await getBotGroupFromAvatars(botName)
  const bot = bots.find(bot => bot.telegram.token === token)
  return {
    token,
    groupId,
    bot,
  }
}

export const bots = Object.values(BOT_NAMES).map(
  token => new Telegraf<MyContext>(token)
)

export function getBotByName(bot_name: string): {
  bot?: Telegraf<MyContext>
  error?: string | null
} {
  logger.info({
    message: 'üîé getBotByName –∑–∞–ø—Ä–æ—à–µ–Ω –¥–ª—è',
    description: 'getBotByName requested for',
    bot_name,
  })

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏–º—Å—è –ª–∏ –º—ã –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –æ–∫—Ä—É–∂–µ–Ω–∏–∏
  if (process.env.NODE_ENV === 'test' || process.env.IS_TESTING === 'true') {
    logger.info({
      message: 'üß™ –¢–µ—Å—Ç–æ–≤–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–æ–∫-–±–æ—Ç–∞',
      description: 'Test environment, returning mock bot',
      bot_name,
    })
    const bot = bots.find(bot => bot.telegram.token === token)

    return { bot }
  }
  //

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –±–æ—Ç–∞ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
  const token = BOT_NAMES[bot_name]
  if (!token) {
    logger.error({
      message: '‚ùå –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏',
      description: 'Bot token not found in configuration',
      bot_name,
      availableBots: Object.keys(BOT_NAMES),
    })
    return { error: 'Bot not found in configuration' }
  }

  logger.info({
    message: 'üîë –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –ø–æ–ª—É—á–µ–Ω –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏',
    description: 'Bot token retrieved from configuration',
    bot_name,
    tokenLength: token.length,
  })

  // –ò—â–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –≤ –º–∞—Å—Å–∏–≤–µ
  const bot = bots.find(bot => bot.telegram.token === token)

  if (!bot) {
    logger.error({
      message: '‚ùå –≠–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω',
      description: 'Bot instance not found',
      bot_name,
      availableBots: bots.map(bot => ({
        token: bot.telegram.token.substring(0, 5) + '...',
        hasBot: !!bot,
      })),
    })
    return { error: 'Bot instance not found' }
  }

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –º–µ—Ç–æ–¥–æ–≤
  if (!bot.telegram || typeof bot.telegram.sendPhoto !== 'function') {
    logger.error({
      message: '‚ùå –≠–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –Ω–∞–π–¥–µ–Ω, –Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –º–µ—Ç–æ–¥—ã',
      description: 'Bot instance found but missing required methods',
      bot_name,
      hasTelegram: !!bot.telegram,
      methods: bot.telegram ? Object.keys(bot.telegram) : [],
    })
    return { error: 'Bot instance is invalid' }
  }

  logger.info({
    message: '‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω',
    description: 'Bot successfully retrieved',
    bot_name,
    hasTelegram: !!bot.telegram,
    methodsCount: bot.telegram ? Object.keys(bot.telegram).length : 0,
  })

  return { bot }
}

export const PULSE_BOT_TOKEN = process.env.BOT_TOKEN_1

export const pulseBot = new Telegraf<MyContext>(PULSE_BOT_TOKEN)

export const supportRequest = async (title: string, data: any) => {
  try {
    await pulseBot.telegram.sendMessage(
      process.env.SUPPORT_CHAT_ID,
      `üöÄ ${title}\n\n${JSON.stringify(data)}`
    )
  } catch (error) {
    throw new Error(`Error supportRequest: ${JSON.stringify(error)}`)
  }
}
